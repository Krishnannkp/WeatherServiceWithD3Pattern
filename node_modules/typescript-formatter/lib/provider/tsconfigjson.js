"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var path = require("path");
var fs = require("fs");
var utils_1 = require("../utils");
function makeFormatCodeOptions(fileName, opts, formatSettings) {
    var baseDir = opts.baseDir ? path.resolve(opts.baseDir) : path.dirname(path.resolve(fileName));
    var configFileName = utils_1.getConfigFileName(baseDir, "tsconfig.json");
    if (!configFileName) {
        return formatSettings;
    }
    if (opts.verbose) {
        console.log("read " + configFileName + " for " + fileName);
    }
    // for `extends` support. It supported from TypeScript 2.1.1.
    // `& { readFile(path: string): string; }` is backword compat for TypeScript compiler 2.0.3 support.
    var host = {
        useCaseSensitiveFileNames: true,
        readDirectory: function (rootDir, _extensions, excludes, _includes) {
            // _extensions -> [ '.ts', '.tsx', '.d.ts' ]
            // _includes   -> [ '**/*' ]
            var files = fs.readdirSync(rootDir);
            return files
                .filter(function (file) { return excludes.every(function (exclude) { return file !== exclude; }); });
        },
        fileExists: function (path) { return fs.existsSync(path); },
        readFile: function (path) { return fs.readFileSync(path, "utf-8"); },
    };
    var rootConfig = utils_1.parseJSON(fs.readFileSync(configFileName, "utf-8"));
    var parsed = ts.parseJsonConfigFileContent(rootConfig, host, baseDir);
    if (parsed.errors && parsed.errors.length !== 0) {
        throw new Error(parsed.errors.map(function (e) { return e.messageText; }).join("\n"));
    }
    if (parsed.options.newLine === ts.NewLineKind.CarriageReturnLineFeed) {
        formatSettings.newLineCharacter = "\r\n";
    }
    else if (parsed.options.newLine === ts.NewLineKind.LineFeed) {
        formatSettings.newLineCharacter = "\n";
    }
    return formatSettings;
}
exports.default = makeFormatCodeOptions;
//# sourceMappingURL=tsconfigjson.js.map